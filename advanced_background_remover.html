<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Pixel Art Background Remover</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
            padding: 20px;
        }
        
        .container {
            max-width: 1000px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        h1 {
            text-align: center;
            margin-bottom: 20px;
            color: #2d3748;
        }
        
        .settings-panel {
            background-color: #f9f9f9;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .setting-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
        }
        
        .color-picker {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .color-preview {
            width: 40px;
            height: 40px;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
        
        .rgb-inputs {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .rgb-input {
            display: flex;
            flex-direction: column;
        }
        
        input[type="number"] {
            width: 60px;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        input[type="range"] {
            width: 100%;
            margin-top: 5px;
        }
        
        .drop-area {
            border: 2px dashed #5a67d8;
            border-radius: 8px;
            padding: 40px 20px;
            text-align: center;
            margin-bottom: 20px;
            background-color: #EBF4FF;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .drop-area.highlight {
            background-color: #C3DAFE;
            border-color: #4C51BF;
        }
        
        .drop-icon {
            font-size: 3rem;
            margin-bottom: 15px;
            color: #5a67d8;
        }
        
        .file-input-btn {
            display: inline-block;
            background-color: #5a67d8;
            color: white;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            margin-top: 10px;
        }
        
        .file-input-btn:hover {
            background-color: #4C51BF;
        }
        
        .preview-area {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .preview-container {
            flex: 1;
            min-width: 300px;
            border: 1px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
        }
        
        .preview-header {
            background-color: #f1f1f1;
            padding: 10px;
            text-align: center;
            font-weight: 600;
            border-bottom: 1px solid #ddd;
        }
        
        .preview-image-container {
            height: 300px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            background-color: #f9f9f9;
        }
        
        .transparent-bg {
            background-image: 
                linear-gradient(45deg, #ccc 25%, transparent 25%), 
                linear-gradient(-45deg, #ccc 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #ccc 75%),
                linear-gradient(-45deg, transparent 75%, #ccc 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }
        
        .preview-image {
            max-width: 100%;
            max-height: 100%;
            display: block;
        }
        
        .actions {
            display: flex;
            justify-content: center;
            gap: 10px;
        }
        
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
        }
        
        .primary-btn {
            background-color: #5a67d8;
            color: white;
        }
        
        .primary-btn:hover {
            background-color: #4C51BF;
        }
        
        .secondary-btn {
            background-color: #e2e8f0;
            color: #4a5568;
        }
        
        .secondary-btn:hover {
            background-color: #cbd5e0;
        }
        
        #error-message {
            color: #e53e3e;
            text-align: center;
            margin-bottom: 15px;
            padding: 10px;
            border-radius: 4px;
            background-color: #FED7D7;
            display: none;
        }
        
        .method-selector {
            margin-bottom: 15px;
        }
        
        .method-selector select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: white;
        }
        
        .setting-info {
            font-size: 0.85rem;
            color: #666;
            margin-top: 5px;
        }
        
        .advanced-settings {
            border-top: 1px solid #ddd;
            padding-top: 15px;
            margin-top: 15px;
        }
        
        .advanced-settings-header {
            font-size: 1rem;
            margin-bottom: 10px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .advanced-settings-content {
            display: none;
        }
        
        .advanced-settings-content.show {
            display: block;
        }
        
        footer {
            text-align: center;
            margin-top: 40px;
            color: #718096;
            font-size: 0.9rem;
        }
        
        .collapse-icon {
            transition: transform 0.3s ease;
        }
        
        .collapse-icon.rotated {
            transform: rotate(180deg);
        }
        
        @media (max-width: 768px) {
            .preview-area {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Advanced Pixel Art Background Remover</h1>
        
        <div id="error-message"></div>
        
        <div class="settings-panel">
            <div class="setting-group method-selector">
                <label for="removal-method">Removal Method:</label>
                <select id="removal-method">
                    <option value="contour">Precise Contour Preservation (Best for Sprites)</option>
                    <option value="smart">Smart Edge Detection</option>
                    <option value="simple">Simple Color Replacement</option>
                </select>
                <div class="setting-info">
                    Precise Contour mode carefully preserves character outlines while removing the background.
                </div>
            </div>
            
            <div class="setting-group">
                <label>Background Color to Remove:</label>
                <div class="color-picker">
                    <div class="color-preview" id="color-preview"></div>
                    <input type="color" id="color-picker" value="#000000">
                </div>
                <div class="rgb-inputs">
                    <div class="rgb-input">
                        <label>R:</label>
                        <input type="number" id="r-value" min="0" max="255" value="0">
                    </div>
                    <div class="rgb-input">
                        <label>G:</label>
                        <input type="number" id="g-value" min="0" max="255" value="0">
                    </div>
                    <div class="rgb-input">
                        <label>B:</label>
                        <input type="number" id="b-value" min="0" max="255" value="0">
                    </div>
                </div>
            </div>
            
            <div class="setting-group">
                <label>Color Threshold: <span id="threshold-display">5</span></label>
                <input type="range" id="threshold-slider" min="0" max="100" value="5">
                <div class="setting-info">
                    Higher values = more pixels removed (useful for color variations)
                </div>
            </div>
            
            <div class="advanced-settings">
                <div class="advanced-settings-header" id="advanced-toggle">
                    <span>Advanced Settings</span>
                    <span class="collapse-icon">‚ñº</span>
                </div>
                <div class="advanced-settings-content" id="advanced-content">
                    <div class="setting-group">
                        <label>Edge Tolerance: <span id="edge-tolerance-display">2</span></label>
                        <input type="range" id="edge-tolerance-slider" min="1" max="10" value="2">
                        <div class="setting-info">
                            Higher values = more aggressive outline preservation
                        </div>
                    </div>
                    
                    <div class="setting-group">
                        <label>Safety Margin: <span id="safety-margin-display">1</span></label>
                        <input type="range" id="safety-margin-slider" min="0" max="5" value="1">
                        <div class="setting-info">
                            Extra pixels to preserve around detected sprite boundaries
                        </div>
                    </div>
                    
                    <div class="setting-group">
                        <label>
                            <input type="checkbox" id="preview-edges-checkbox">
                            Preview Detected Edges
                        </label>
                        <div class="setting-info">
                            Shows the detected sprite boundaries in red (helps with troubleshooting)
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="drop-area" id="drop-area">
            <div class="drop-icon">üìÅ</div>
            <p>Drag & Drop your PNG sprite here</p>
            <p>or</p>
            <label class="file-input-btn">
                Browse Files
                <input type="file" id="file-input" accept="image/png" hidden>
            </label>
        </div>
        
        <div class="preview-area" id="preview-area" style="display: none;">
            <div class="preview-container">
                <div class="preview-header">Original</div>
                <div class="preview-image-container">
                    <img id="original-preview" class="preview-image" src="" alt="Original Image">
                </div>
            </div>
            
            <div class="preview-container">
                <div class="preview-header">Processed</div>
                <div class="preview-image-container transparent-bg">
                    <img id="processed-preview" class="preview-image" src="" alt="Processed Image">
                </div>
            </div>
        </div>
        
        <div class="actions" id="actions" style="display: none;">
            <button id="download-btn" class="primary-btn">Download</button>
            <button id="reset-btn" class="secondary-btn">Process Another Image</button>
        </div>
        
        <footer>
            <p>Advanced Pixel Art Background Remover | Created for Roberto's Rush Game</p>
        </footer>
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // DOM Elements
            const methodSelector = document.getElementById('removal-method');
            const colorPicker = document.getElementById('color-picker');
            const colorPreview = document.getElementById('color-preview');
            const rValue = document.getElementById('r-value');
            const gValue = document.getElementById('g-value');
            const bValue = document.getElementById('b-value');
            const thresholdSlider = document.getElementById('threshold-slider');
            const thresholdDisplay = document.getElementById('threshold-display');
            const edgeToleranceSlider = document.getElementById('edge-tolerance-slider');
            const edgeToleranceDisplay = document.getElementById('edge-tolerance-display');
            const safetyMarginSlider = document.getElementById('safety-margin-slider');
            const safetyMarginDisplay = document.getElementById('safety-margin-display');
            const previewEdgesCheckbox = document.getElementById('preview-edges-checkbox');
            const advancedToggle = document.getElementById('advanced-toggle');
            const advancedContent = document.getElementById('advanced-content');
            const collapseIcon = document.querySelector('.collapse-icon');
            const dropArea = document.getElementById('drop-area');
            const fileInput = document.getElementById('file-input');
            const previewArea = document.getElementById('preview-area');
            const originalPreview = document.getElementById('original-preview');
            const processedPreview = document.getElementById('processed-preview');
            const actions = document.getElementById('actions');
            const downloadBtn = document.getElementById('download-btn');
            const resetBtn = document.getElementById('reset-btn');
            const errorMessage = document.getElementById('error-message');
            
            // State
            let currentImage = null;
            let processedCanvas = null;
            
            // Initialize UI
            colorPreview.style.backgroundColor = '#000000';
            
            // Toggle advanced settings
            advancedToggle.addEventListener('click', function() {
                advancedContent.classList.toggle('show');
                collapseIcon.classList.toggle('rotated');
            });
            
            // Event Listeners
            colorPicker.addEventListener('input', updateColorFromPicker);
            rValue.addEventListener('input', updateColorFromRGB);
            gValue.addEventListener('input', updateColorFromRGB);
            bValue.addEventListener('input', updateColorFromRGB);
            thresholdSlider.addEventListener('input', updateThreshold);
            edgeToleranceSlider.addEventListener('input', updateEdgeTolerance);
            safetyMarginSlider.addEventListener('input', updateSafetyMargin);
            methodSelector.addEventListener('change', processImage);
            previewEdgesCheckbox.addEventListener('change', processImage);
            
            // Drag and drop
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropArea.addEventListener(eventName, preventDefaults, false);
            });
            
            ['dragenter', 'dragover'].forEach(eventName => {
                dropArea.addEventListener(eventName, highlight, false);
            });
            
            ['dragleave', 'drop'].forEach(eventName => {
                dropArea.addEventListener(eventName, unhighlight, false);
            });
            
            dropArea.addEventListener('drop', handleDrop, false);
            fileInput.addEventListener('change', handleFileSelect, false);
            
            downloadBtn.addEventListener('click', downloadImage);
            resetBtn.addEventListener('click', resetApp);
            
            // Functions
            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }
            
            function highlight() {
                dropArea.classList.add('highlight');
            }
            
            function unhighlight() {
                dropArea.classList.remove('highlight');
            }
            
            function updateColorFromPicker() {
                const color = colorPicker.value;
                colorPreview.style.backgroundColor = color;
                
                // Convert hex to RGB
                const r = parseInt(color.substring(1, 3), 16);
                const g = parseInt(color.substring(3, 5), 16);
                const b = parseInt(color.substring(5, 7), 16);
                
                rValue.value = r;
                gValue.value = g;
                bValue.value = b;
                
                // Process image if one is loaded
                if (currentImage) {
                    processImage();
                }
            }
            
            function updateColorFromRGB() {
                const r = parseInt(rValue.value) || 0;
                const g = parseInt(gValue.value) || 0;
                const b = parseInt(bValue.value) || 0;
                
                // Constrain values
                rValue.value = Math.min(255, Math.max(0, r));
                gValue.value = Math.min(255, Math.max(0, g));
                bValue.value = Math.min(255, Math.max(0, b));
                
                // Convert to hex
                const hex = '#' + 
                    rValue.value.toString(16).padStart(2, '0') + 
                    gValue.value.toString(16).padStart(2, '0') + 
                    bValue.value.toString(16).padStart(2, '0');
                
                colorPicker.value = hex;
                colorPreview.style.backgroundColor = hex;
                
                // Process image if one is loaded
                if (currentImage) {
                    processImage();
                }
            }
            
            function updateThreshold() {
                thresholdDisplay.textContent = thresholdSlider.value;
                
                // Process image if one is loaded
                if (currentImage) {
                    processImage();
                }
            }
            
            function updateEdgeTolerance() {
                edgeToleranceDisplay.textContent = edgeToleranceSlider.value;
                
                // Process image if one is loaded
                if (currentImage) {
                    processImage();
                }
            }
            
            function updateSafetyMargin() {
                safetyMarginDisplay.textContent = safetyMarginSlider.value;
                
                // Process image if one is loaded
                if (currentImage) {
                    processImage();
                }
            }
            
            function handleDrop(e) {
                const dt = e.dataTransfer;
                const files = dt.files;
                
                if (files.length > 0) {
                    handleFile(files[0]);
                }
            }
            
            function handleFileSelect(e) {
                const files = e.target.files;
                
                if (files.length > 0) {
                    handleFile(files[0]);
                }
            }
            
            function handleFile(file) {
                // Check if file is a PNG
                if (!file.type.match('image/png')) {
                    showError("Please select a PNG file!");
                    return;
                }
                
                // Clear any previous errors
                hideError();
                
                // Read the file
                const reader = new FileReader();
                
                reader.onload = function(event) {
                    const img = new Image();
                    img.onload = function() {
                        currentImage = img;
                        displayOriginalImage(img);
                        processImage();
                        
                        // Show preview area and actions
                        dropArea.style.display = 'none';
                        previewArea.style.display = 'flex';
                        actions.style.display = 'flex';
                    };
                    img.src = event.target.result;
                };
                
                reader.readAsDataURL(file);
            }
            
            function displayOriginalImage(img) {
                originalPreview.src = img.src;
            }
            
            function processImage() {
                if (!currentImage) return;
                
                // Get current settings
                const r = parseInt(rValue.value);
                const g = parseInt(gValue.value);
                const b = parseInt(bValue.value);
                const threshold = parseInt(thresholdSlider.value);
                const edgeTolerance = parseInt(edgeToleranceSlider.value);
                const safetyMargin = parseInt(safetyMarginSlider.value);
                const method = methodSelector.value;
                const previewEdges = previewEdgesCheckbox.checked;
                
                // Create canvas for processing
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                // Set dimensions
                canvas.width = currentImage.width;
                canvas.height = currentImage.height;
                
                // Draw image
                ctx.drawImage(currentImage, 0, 0);
                
                // Get image data
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                
                if (method === 'simple') {
                    // Simple method: replace all matching pixels
                    simpleBackgroundRemoval(data, canvas.width, canvas.height, r, g, b, threshold);
                } else if (method === 'smart') {
                    // Smart method: use flood fill to identify background pixels
                    smartBackgroundRemoval(data, canvas.width, canvas.height, r, g, b, threshold);
                } else {
                    // Contour method: preserve detailed sprite outlines
                    contourPreservationRemoval(data, canvas.width, canvas.height, r, g, b, threshold, edgeTolerance, safetyMargin, previewEdges);
                }
                
                // Put processed image data back
                ctx.putImageData(imageData, 0, 0);
                
                // Save processed canvas for download
                processedCanvas = canvas;
                
                // Update preview
                processedPreview.src = canvas.toDataURL('image/png');
            }
            
            function simpleBackgroundRemoval(data, width, height, r, g, b, threshold) {
                // Process each pixel
                for (let i = 0; i < data.length; i += 4) {
                    const pixelR = data[i];
                    const pixelG = data[i + 1];
                    const pixelB = data[i + 2];
                    
                    // Check if pixel color is close to background color
                    if (
                        Math.abs(pixelR - r) < threshold &&
                        Math.abs(pixelG - g) < threshold &&
                        Math.abs(pixelB - b) < threshold
                    ) {
                        // Make transparent
                        data[i + 3] = 0;
                    }
                }
            }
            
            function smartBackgroundRemoval(data, width, height, r, g, b, threshold) {
                // Create a visited array to track which pixels have been processed
                const visited = new Array(width * height).fill(false);
                
                // Create a background mask (true for background pixels)
                const background = new Array(width * height).fill(false);
                
                // Utility function to check if a pixel is similar to background color
                function isSimilarToBackground(index) {
                    const pixelR = data[index];
                    const pixelG = data[index + 1];
                    const pixelB = data[index + 2];
                    
                    return (
                        Math.abs(pixelR - r) < threshold &&
                        Math.abs(pixelG - g) < threshold &&
                        Math.abs(pixelB - b) < threshold
                    );
                }
                
                // Flood fill implementation
                function floodFill(startX, startY) {
                    const stack = [];
                    stack.push({x: startX, y: startY});
                    
                    while (stack.length > 0) {
                        const pixel = stack.pop();
                        const x = pixel.x;
                        const y = pixel.y;
                        
                        // Skip if out of bounds
                        if (x < 0 || x >= width || y < 0 || y >= height) {
                            continue;
                        }
                        
                        // Calculate pixel index
                        const index = (y * width + x) * 4;
                        const visitedIndex = y * width + x;
                        
                        // Skip if already visited or not background color
                        if (visited[visitedIndex] || !isSimilarToBackground(index)) {
                            continue;
                        }
                        
                        // Mark as visited and background
                        visited[visitedIndex] = true;
                        background[visitedIndex] = true;
                        
                        // Add neighboring pixels to stack
                        stack.push({x: x + 1, y: y});
                        stack.push({x: x - 1, y: y});
                        stack.push({x: x, y: y + 1});
                        stack.push({x: x, y: y - 1});
                    }
                }
                
                // Start flood fill from all four corners
                floodFill(0, 0);                         // Top-left
                floodFill(width - 1, 0);                 // Top-right
                floodFill(0, height - 1);                // Bottom-left
                floodFill(width - 1, height - 1);        // Bottom-right
                
                // Border fill - go along all edges to catch disconnected areas
                // Top and bottom edges
                for (let x = 0; x < width; x++) {
                    floodFill(x, 0);
                    floodFill(x, height - 1);
                }
                
                // Left and right edges
                for (let y = 0; y < height; y++) {
                    floodFill(0, y);
                    floodFill(width - 1, y);
                }
                
                // Make background pixels transparent
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const visitedIndex = y * width + x;
                        if (background[visitedIndex]) {
                            const dataIndex = visitedIndex * 4;
                            data[dataIndex + 3] = 0;  // Set alpha to 0
                        }
                    }
                }
            }
            
            function contourPreservationRemoval(data, width, height, r, g, b, threshold, edgeTolerance, safetyMargin, previewEdges) {
                // Create arrays to track background and edge pixels
                const background = new Array(width * height).fill(false);
                const edges = new Array(width * height).fill(false);
                const visited = new Array(width * height).fill(false);
                
                // 1. First pass: Identify definite background pixels
                // Flood fill from edges to identify background
                floodFillBackground();
                
                // 2. Second pass: Detect edges and contours
                detectEdges();
                
                // 3. Apply safety margin around edges
                applySafetyMargin();
                
                // 4. Final pass: Make background pixels transparent
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const index = y * width + x;
                        const dataIndex = index * 4;
                        
                        if (background[index] && !edges[index]) {
                            // Make background transparent
                            data[dataIndex + 3] = 0;
                        } else if (previewEdges && edges[index]) {
                            // Visualize edges in red (for debugging)
                            data[dataIndex] = 255;
                            data[dataIndex + 1] = 0;
                            data[dataIndex + 2] = 0;
                        }
                    }
                }
                
                // Utility functions
                
                // Check if a pixel is similar to background color
                function isSimilarToBackground(x, y) {
                    if (x < 0 || x >= width || y < 0 || y >= height) return false;
                    
                    const index = (y * width + x) * 4;
                    const pixelR = data[index];
                    const pixelG = data[index + 1];
                    const pixelB = data[index + 2];
                    
                    return (
                        Math.abs(pixelR - r) < threshold &&
                        Math.abs(pixelG - g) < threshold &&
                        Math.abs(pixelB - b) < threshold
                    );
                }
                
                // Flood fill to identify background pixels
                function floodFillBackground() {
                    const queue = [];
                    
                    // Start from the edges of the image
                    // Top and bottom rows
                    for (let x = 0; x < width; x++) {
                        if (isSimilarToBackground(x, 0)) {
                            queue.push({x, y: 0});
                            visited[0 * width + x] = true;
                            background[0 * width + x] = true;
                        }
                        
                        if (isSimilarToBackground(x, height - 1)) {
                            queue.push({x, y: height - 1});
                            visited[(height - 1) * width + x] = true;
                            background[(height - 1) * width + x] = true;
                        }
                    }
                    
                    // Left and right columns
                    for (let y = 0; y < height; y++) {
                        if (isSimilarToBackground(0, y)) {
                            queue.push({x: 0, y});
                            visited[y * width + 0] = true;
                            background[y * width + 0] = true;
                        }
                        
                        if (isSimilarToBackground(width - 1, y)) {
                            queue.push({x: width - 1, y});
                            visited[y * width + (width - 1)] = true;
                            background[y * width + (width - 1)] = true;
                        }
                    }
                    
                    // BFS to fill background
                    while (queue.length > 0) {
                        const {x, y} = queue.shift();
                        
                        // Check 4-connected neighbors
                        const neighbors = [
                            {x: x + 1, y},
                            {x: x - 1, y},
                            {x, y: y + 1},
                            {x, y: y - 1}
                        ];
                        
                        for (const neighbor of neighbors) {
                            const nx = neighbor.x;
                            const ny = neighbor.y;
                            
                            // Skip if out of bounds
                            if (nx < 0 || nx >= width || ny < 0 || ny >= height) continue;
                            
                            const neighborIndex = ny * width + nx;
                            
                            // Skip if already visited
                            if (visited[neighborIndex]) continue;
                            
                            // Mark as visited
                            visited[neighborIndex] = true;
                            
                            // If similar to background, add to queue and mark as background
                            if (isSimilarToBackground(nx, ny)) {
                                queue.push({x: nx, y: ny});
                                background[neighborIndex] = true;
                            }
                        }
                    }
                }
                
                // Detect edges using Sobel-like operator and color transitions
                function detectEdges() {
                    for (let y = 1; y < height - 1; y++) {
                        for (let x = 1; x < width - 1; x++) {
                            const index = y * width + x;
                            
                            // Skip if not a background pixel (we only care about edges between background & sprite)
                            if (!background[index]) continue;
                            
                            // Check 8-connected neighbors for non-background pixels
                            let nonBackgroundNeighbors = 0;
                            let significantColorDifferences = 0;
                            
                            // Check immediate neighbors (4-connected)
                            const neighbors = [
                                {x: x + 1, y},
                                {x: x - 1, y},
                                {x, y: y + 1},
                                {x, y: y - 1},
                                {x: x + 1, y: y + 1},
                                {x: x - 1, y: y - 1},
                                {x: x + 1, y: y - 1},
                                {x: x - 1, y: y + 1}
                            ];
                            
                            for (const neighbor of neighbors) {
                                const nx = neighbor.x;
                                const ny = neighbor.y;
                                
                                // Skip if out of bounds
                                if (nx < 0 || nx >= width || ny < 0 || ny >= height) continue;
                                
                                const neighborIndex = ny * width + nx;
                                
                                // Count non-background neighbors
                                if (!background[neighborIndex]) {
                                    nonBackgroundNeighbors++;
                                    
                                    // Check for significant color difference (detect sprite edges)
                                    const currentPixelIndex = index * 4;
                                    const neighborPixelIndex = neighborIndex * 4;
                                    
                                    const dr = Math.abs(data[currentPixelIndex] - data[neighborPixelIndex]);
                                    const dg = Math.abs(data[currentPixelIndex + 1] - data[neighborPixelIndex + 1]);
                                    const db = Math.abs(data[currentPixelIndex + 2] - data[neighborPixelIndex + 2]);
                                    
                                    if (dr > 20 || dg > 20 || db > 20) {
                                        significantColorDifferences++;
                                    }
                                }
                            }
                            
                            // If we have multiple non-background neighbors or color transitions,
                            // mark as an edge based on edge tolerance
                            if (nonBackgroundNeighbors >= edgeTolerance || significantColorDifferences >= edgeTolerance) {
                                edges[index] = true;
                            }
                        }
                    }
                }
                
                // Apply safety margin around detected edges
                function applySafetyMargin() {
                    if (safetyMargin <= 0) return;
                    
                    // Create a copy of the edges array
                    const edgesCopy = [...edges];
                    
                    // For each edge pixel, mark neighbors within safety margin also as edges
                    for (let y = 0; y < height; y++) {
                        for (let x = 0; x < width; x++) {
                            const index = y * width + x;
                            
                            if (edgesCopy[index]) {
                                // Expand margin around this edge pixel
                                for (let dy = -safetyMargin; dy <= safetyMargin; dy++) {
                                    for (let dx = -safetyMargin; dx <= safetyMargin; dx++) {
                                        const nx = x + dx;
                                        const ny = y + dy;
                                        
                                        // Skip if out of bounds
                                        if (nx < 0 || nx >= width || ny < 0 || ny >= height) continue;
                                        
                                        const neighborIndex = ny * width + nx;
                                        edges[neighborIndex] = true;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            function downloadImage() {
                if (!processedCanvas) return;
                
                // Create download link
                const link = document.createElement('a');
                link.download = 'roberto_sprite.png';
                link.href = processedCanvas.toDataURL('image/png');
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
            
            function resetApp() {
                // Reset state
                currentImage = null;
                processedCanvas = null;
                
                // Reset UI
                dropArea.style.display = 'block';
                previewArea.style.display = 'none';
                actions.style.display = 'none';
                fileInput.value = '';
                hideError();
            }
            
            function showError(message) {
                errorMessage.textContent = message;
                errorMessage.style.display = 'block';
            }
            
            function hideError() {
                errorMessage.style.display = 'none';
            }
        });
    </script>
</body>
</html>
